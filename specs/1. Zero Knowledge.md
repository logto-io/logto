I want to implement a way where apps authenticated with my oidc provider logto can consistently get a secret key without the server ver knowing this. A zero knowledge encryption key.

To do this I will fork logto. I actually have the fork already here.

To do this the client/js will essentially need to generate a secret key, encrypt it with their password and store it on the server. So the server only ever gets the encrypted key.

This is complicated so I will outline the full flow I think is needed.

# Login Flow

1. User goes to https://localhost:5003/demo-app
2. Demo-app generates a new `privKey` and `pubKey` and stores in localStorage
3. User gets redirect to login page (http://localhost:3001/sign-in?public_key=...) with public key
4. User enters their password
5. Password gets split into `serverPassword` and `clientPassword`
6. Login page sends to server {username, password: `serverPassword` }

--- IF ---
## If secret does not exist
7a. Server verifies password is correct and responds with {
    verificationId: "hy2h768cei3dcp48b0tv3",
    encryptedSecret: null
}
7b. Client generates `secret` (a secure random string)
7c. Client generates `encryptedSecret` encrypt(secret).with(clientPassword)
7d. Client submits `encryptedSecret` to PUT:/api/experience/secret/user
7e. Server stores the `encryptedSecret` against the user's data
7f. Client generates `encryptedClientSecret` encrypt(secret).with(pubKey)
7g. Client submits `encryptedClientSecret` to PUT:/api/experience/secret/session

## If secret already exists
7a. Server verifies password is correct and responds with {
    verificationId: "hy2h768cei3dcp48b0tv3",
    encryptedSecret: `encryptedSecret`
}
7b. Client generates `secret` decrypt(encryptedSecret).with(clientPassword)
7c. Client generates `encryptedClientSecret` encrypt(secret).with(pubKey)
7d. Client submits `encryptedClientSecret` to PUT:/api/experience/secret/session
--- END IF ---

8. Server stores `encryptedClientSecret` in the experience interaction
9. User completes OAuth authorization
10. **During token exchange, server includes `encryptedClientSecret` in the token response**
11. Demo-app receives token response with `encryptedClientSecret`
12. Demo-app decrypts `secret` = decrypt(encryptedClientSecret).with(privKey)
13. Demo-app stores `secret` in localStorage for future use

The key change is step 10 - we include the `encryptedClientSecret` directly in the OAuth token response. This could be:
- As a custom claim in the ID token
- As an additional field in the token endpoint response
- As a parameter in the redirect URI (though this is less secure)

This way, the app gets the encrypted secret immediately when it completes the OAuth flow, and can store it however it wants. No need for a separate API call or long-term persistence on the server side.
