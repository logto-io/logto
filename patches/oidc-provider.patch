diff --git a/lib/actions/authorization/one_redirect_uri_clients.js b/lib/actions/authorization/one_redirect_uri_clients.js
index 2f1a07182..d823c363e 100755
--- a/lib/actions/authorization/one_redirect_uri_clients.js
+++ b/lib/actions/authorization/one_redirect_uri_clients.js
@@ -11,7 +11,12 @@ export default function oneRedirectUriClients(ctx, next) {
 
   const { params, client } = ctx.oidc;
 
-  if (params.redirect_uri === undefined && client.redirectUris.length === 1) {
+  if (
+    params.redirect_uri === undefined
+    && client.redirectUris.length === 1
+    // Wildcard redirect URIs must always be explicitly provided.
+    && !client.redirectUris[0].includes('*')
+  ) {
     ctx.oidc.redirectUriCheckPerformed = true;
     [params.redirect_uri] = client.redirectUris;
   }
diff --git a/lib/models/client.js b/lib/models/client.js
index 903f909cf..6a746adf9 100755
--- a/lib/models/client.js
+++ b/lib/models/client.js
@@ -48,6 +48,153 @@ function URLparse(url) {
   }
 }
 
+const escapeRegExp = (value) => value.replace(/[\\^$.*+?()[\]{}|]/g, '\\$&');
+
+const getEffectivePort = (protocol, port) => {
+  if (port) {
+    return port;
+  }
+
+  switch (protocol) {
+    case 'http:':
+      return '80';
+    case 'https:':
+      return '443';
+    default:
+      return '';
+  }
+};
+
+const matchHostnameWithWildcards = (patternHostname, actualHostname) => {
+  const pattern = String(patternHostname).toLowerCase();
+  const actual = String(actualHostname).toLowerCase();
+
+  if (!pattern.includes('*')) {
+    return pattern === actual;
+  }
+
+  const patternLabels = pattern.split('.');
+  const actualLabels = actual.split('.');
+
+  if (patternLabels.length !== actualLabels.length) {
+    return false;
+  }
+
+  return patternLabels.every((labelPattern, index) => {
+    const label = actualLabels[index] ?? '';
+
+    if (!labelPattern.includes('*')) {
+      return labelPattern === label;
+    }
+
+    const regex = new RegExp(
+      `^${labelPattern.split('*').map(escapeRegExp).join('[^.]+')}$`,
+      'i',
+    );
+    return regex.test(label);
+  });
+};
+
+const matchPathWithWildcards = (patternPathname, actualPathname) => {
+  if (!patternPathname.includes('*')) {
+    return patternPathname === actualPathname;
+  }
+
+  const regex = new RegExp(`^${patternPathname.split('*').map(escapeRegExp).join('.*')}$`);
+  return regex.test(actualPathname);
+};
+
+const parseWildcardUrlPattern = (pattern) => {
+  const schemeSeparatorIndex = pattern.indexOf('://');
+  if (schemeSeparatorIndex <= 0) {
+    return null;
+  }
+
+  // Disallow wildcards in scheme.
+  if (pattern.slice(0, schemeSeparatorIndex).includes('*')) {
+    return null;
+  }
+
+  // Disallow wildcards in query/hash (matching stays deterministic and safer).
+  const queryIndex = pattern.indexOf('?');
+  if (queryIndex >= 0 && pattern.slice(queryIndex).includes('*')) {
+    return null;
+  }
+
+  const hashIndex = pattern.indexOf('#');
+  if (hashIndex >= 0 && pattern.slice(hashIndex).includes('*')) {
+    return null;
+  }
+
+  const parsed = URLparse(pattern.replace(/\*/g, 'wildcard'));
+  if (!parsed) {
+    return null;
+  }
+
+  const rest = pattern.slice(schemeSeparatorIndex + 3);
+  const authority = rest.split(/[/?#]/)[0] ?? '';
+  if (!authority || authority.includes('@') || authority.startsWith('[')) {
+    return null;
+  }
+
+  const lastColonIndex = authority.lastIndexOf(':');
+  const hasPort = lastColonIndex > -1 && authority.indexOf(':') === lastColonIndex;
+  if (hasPort && authority.slice(lastColonIndex + 1).includes('*')) {
+    return null;
+  }
+
+  const hostnamePattern = hasPort ? authority.slice(0, lastColonIndex) : authority;
+
+  // When wildcard is used in hostname, require at least one dot to avoid overly broad patterns.
+  if (hostnamePattern.includes('*') && !hostnamePattern.includes('.')) {
+    return null;
+  }
+
+  const pathStartIndex = schemeSeparatorIndex + 3 + authority.length;
+  const pathEndIndex = Math.min(
+    ...[pattern.length, queryIndex >= 0 ? queryIndex : pattern.length, hashIndex >= 0 ? hashIndex : pattern.length],
+  );
+
+  const pathnamePattern = pattern.slice(pathStartIndex, pathEndIndex) || '/';
+
+  return {
+    protocol: parsed.protocol,
+    port: parsed.port,
+    hostnamePattern,
+    pathnamePattern,
+    search: parsed.search,
+    hash: parsed.hash,
+  };
+};
+
+const wildcardUrlMatch = (pattern, actual) => {
+  const parsedPattern = parseWildcardUrlPattern(pattern);
+  if (!parsedPattern) {
+    return false;
+  }
+
+  if (actual.protocol !== parsedPattern.protocol) {
+    return false;
+  }
+
+  if (
+    getEffectivePort(actual.protocol, actual.port)
+    !== getEffectivePort(parsedPattern.protocol, parsedPattern.port)
+  ) {
+    return false;
+  }
+
+  if (!matchHostnameWithWildcards(parsedPattern.hostnamePattern, actual.hostname)) {
+    return false;
+  }
+
+  if (!matchPathWithWildcards(parsedPattern.pathnamePattern, actual.pathname)) {
+    return false;
+  }
+
+  return actual.search === parsedPattern.search && actual.hash === parsedPattern.hash;
+};
+
 const validateJWKS = (jwks) => {
   if (jwks !== undefined) {
     if (!Array.isArray(jwks?.keys) || !jwks.keys.every(isPlainObject)) {
@@ -515,7 +662,11 @@ export default function getClient(provider) {
       const parsed = URLparse(value);
       if (!parsed) return false;
 
-      const match = this.redirectUris.find((allowed) => URLparse(allowed)?.href === parsed.href);
+      const match = this.redirectUris.find((allowed) => (
+        allowed.includes('*')
+          ? wildcardUrlMatch(allowed, parsed)
+          : URLparse(allowed)?.href === parsed.href
+      ));
       if (
         !!match
         || this.applicationType !== 'native'
@@ -551,8 +702,11 @@ export default function getClient(provider) {
     postLogoutRedirectUriAllowed(value) {
       const parsed = URLparse(value);
       if (!parsed) return false;
-      return !!this.postLogoutRedirectUris
-        .find((allowed) => URLparse(allowed)?.href === parsed.href);
+      return !!this.postLogoutRedirectUris.find((allowed) => (
+        allowed.includes('*')
+          ? wildcardUrlMatch(allowed, parsed)
+          : URLparse(allowed)?.href === parsed.href
+      ));
     }
 
     static async validate(metadata) {
